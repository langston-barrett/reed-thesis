\documentclass[./thesis.tex]{subfiles}
\begin{document}
\chapter{Type theory}
\label{chap:type-theory}

Whatever the meaning of the Curry-Howard correspondence, its utility is
circumscribed by the fact that \IPL{}/\TLC{} as
presented do not match the expressive power of classical \FOL{}:
there are no types expressing quantification over some domain, nor propositions
or relations that may ``apply'' to terms and variables. Certainly, they are
missing the infinite structures of classical set theory.

The system described in this section enriches \TLC{} with
\textit{dependent types} (\cref{sec:dependent-types}) and a few more base types,
including our first examples of \textit{inductive types}
(\cref{subsec:natural-numbers-and-lists}). Additionally, we define and include
Voevodsky's univalence axiom (\cref{sec:univalence}). The
resulting system (univalent type theory, or \UTT{}) has similar
expressive power to \ZFC{}+\FOL{}.\footnote{Indeed, the
  ``set types'' (\cref{def:sets}) behave very much like sets in classical
  mathematics, especially when a few classically-minded axioms are assumed. See
  \cite{book} for more commentary.

  Conversely, \ZFC{} and infinitely many inaccessible cardinals models the
  similar system \HoTT{} (via Voevodsky's simplicial set construction).}

\UTT{} mirrors the type theory $\caH'$ of \cite{homotopy-limits}, which itself
is the system $\caH$ in \cite{inductive} and \cite{homotopy-initial} with the
addition of the natural numbers and universes. The results of
\cref{chap:coinductive-types-in-univalent-type-theory} don't
require the full power of homotopy type theory (\HoTT), specifically we leave
out the axioms asserting the existence of higher inductive types.

\begin{notation}
  Henceforth, we denote variables and meta-variables with the same
  script.
\end{notation}

\section{Dependent types}
\label{sec:dependent-types}

One of the slogans of dependently typed programming is that ``types are
terms''. Propositions, like proof terms, can now be subsumed as objects of study
in their own right.

\begin{definition}
	A \define{dependent type} or \define{type family} is a term with a free
  variable of a specified type, which, when filled in with any term of said
  type, is a type. In other words, $B$ is a dependent type with variable of type
  $A$ if for some $Γ$,
  \begin{equation*}
    Γ,a:A⊢\type{B}.
  \end{equation*}
  That is, a dependent type is a \textit{type} that \textit{depends} on a
  \textit{value}. 
\end{definition}

In the interpretation of types as propositions, dependent types correspond to
predicates. The following illustration uses several concepts yet to be
introduced, trust that it can be made precise after the next few sections.
Suppose we have a type $ℕ$ with introduction rules (or ``constructors'')
\begin{align*}
  \prftree[r]{}
    {}
    {Γ ⊢ 0:\ℕ} &&
  \prftree[r]{}
    {Γ ⊢ n:\ℕ}
    {Γ ⊢ \apply{\suc}{n}:\ℕ}
\end{align*}
($0$ is what a logician might call a ``non-logical constant'' and $\suc$ a
``function symbol''). We might define a type family
\begin{alignat*}{3}
  &\apply{\ttfun{Even}}{0} &&\defeq \unittype  \\
  &\apply{\ttfun{Even}}{(\apply{\suc}{0})} &&\defeq \emptytype  \\
  &\apply{\ttfun{Even}}{(\apply{\suc}{(\apply{\suc}{n})})} &&\defeq \apply{\ttfun{Even}}{n}
\end{alignat*}
Then $\apply{\ttfun{Even}}{n}$ is inhabited ($≅$true) when $n$ is even, and
empty ($≅$false) otherwise.

\begin{remark}
	Here's an opportunity for confusion: is a type like $\ℕ$ ``true''? It's
  certainly inhabited. Again, we, as humans, must decide which types to
  interpret as propositions, properties, etc. \Cref{sec:h-levels and truncation}
  covers types that essentially contain no other information other than whether
  or not they are inhabited, these are called ``propositions''.
\end{remark}

\subsection{Π-types}
\label{subsec:pi-types}

The \define{dependent function type}, or Π-type, generalizes the direct product
and function types. It is formed via the following rule:
\begin{equation*}
  \prftree[r]{}
    {Γ ⊢ \type{A}}
    {Γ, a:A ⊢ \type{B}}
    {Γ ⊢ \type{\pitt{a:A}{\apply{B}{a}}}}
\end{equation*}
It is \textit{crucial} to remember that the Π (just like λ) scopes over the
entire rest of the expression, unless otherwise delineated by parentheses.
This type represents functions with output \textit{types} that depend on the
\textit{value} of an \textit{input}. They associate to each $a:A$ some element
of the type $\apply{B}{a}$. Thus, the introduction rule (dropping hypotheses
that appear in the formation rule):
\begin{equation*}
  \prftree[r]{}
    {Γ, a:A ⊢ b:\apply{B}{a}}
    {Γ ⊢ \λ{a}{b}:\pitt{a:A}{\apply{B}{a}}}
\end{equation*}
where the term $b$ usually has a free occurrence of $a$. If it doesn't, the Π-type
specializes to the normal function type. The elimination, computation, and
unicity rules are also straightforward generalizations of normal functions types:
\begin{gatherjot}
  \prftree[r]{}
    {Γ ⊢ {f}:\pitt{a:A}{\apply{B}{a}}}
    {Γ ⊢ {a}:{A}}
    {Γ ⊢ \apply{p}{a}:\apply{B}{a}}
  \qquad
  \prftree[r]{β}
    {Γ, a:A ⊢ b:\apply{B}{a}}
    {Γ ⊢ x:A}
    {Γ ⊢ \apply{\λ{a}{b}}{x}\jdeq b[a\defeq x]:\apply{B}{a}} \\
  \prftree[r]{η}
    {Γ ⊢ f : \pitt{a:A}{\apply{B}{a}}}
    {Γ ⊢ \λ{x}{\apply{f}{x}}\jdeq f:\pitt{a:A}{\apply{B}{a}}}
\end{gatherjot}

Under the types-as-propositions interpretation, Π-types correspond to universal
quantification. A term of type $\∏{a:A}{\apply{B}{a}}$ takes each $a:A$ to a
proof or witness that $B$ holds of $a$. Loads of examples to follow throughout.

\begin{example}
  The following example illustrates that dependent types truly allow for
  \textit{arbitrary expressions} to appear at the type level:
  \begin{gather*}
    f:\∏{t:A+B}{\apppply{\case}{(\λ{a}{\unittype})}{(\λ{b}{\unittype×\unittype})}{t}} \\
    f \defeq \appply{\case}{(\λ{a}{\unitelem})}{(\λ{b}{(\unitelem,\unitelem)})}.
  \end{gather*}
  For $a:A$ and $b:B$, the elimination rules for $+$ and Π give
  \begin{align*}
    \apply{f}{(\apply{\inl}{a})} &\jdeq \unitelem \\
    \apply{f}{(\apply{\inr}{b})} &\jdeq (\unitelem, \unitelem)
  \end{align*}
  which have \textit{different types}.
\end{example}

To comprehend less contrived examples of dependent types and Π-types, one must
first understand universes.

\subsection{The universe}
\label{subsec:the-universe}

Another slogan of dependently typed programming is ``All terms must have a
type''. What, if anything, is the type of types?\footnote{Caution: This thesis
  doesn't explain the rules for universes nearly as fully as those for all other
  types.}

\begin{definition}\label[definition]{def:universes}
  All the base types we have considered up to this point ($⊤$, $⊥$) are members
  of a \define{universe} \universei{0}, formed via the following rule:
  \begin{equation*}
    \prftree[r]{}
      {}
      {Γ⊢\type{\universei{0}}}
  \end{equation*}
  All type formers preserve membership of this universe, i.e.\
  \begin{gatherjot}
    \prftree[r]{}{}{Γ⊢⊤:\universei{0}}
    \qquad
    \prftree[r]{}{}{Γ⊢⊥:\universei{0}}
    \qquad
    \prftree[r]{}
      {Γ ⊢ {a}:\universei{0}}
      {Γ ⊢ {b}:\universei{0}}
      {Γ⊢{a}×{b}:\universei{0}} \\
    \prftree[r]{}
      {Γ ⊢ {a}:\universei{0}}
      {Γ ⊢ {b}:\universei{0}}
      {Γ⊢{a}+{b}:\universei{0}} 
    \qquad
    \prftree[r]{}
      {Γ ⊢ A:\universei{0}}
      {Γ, a:A ⊢ B:\universei{0}}
      {Γ ⊢ \pitt{a:A}{\apply{B}{a}}:\universei{0}}
  \end{gatherjot}
  Conversely, if something is a member of the universe, we may conclude that
  it is a type:
  \begin{equation*}
    \prftree[r]{}
      {Γ ⊢ {a}:\universei{0}}
      {Γ⊢\type{{a}}}
  \end{equation*}
\end{definition}

Using the introduction rule for functions, we may (perhaps imprecisely)
identify dependent types with \textit{functions} $B:A→\universei{0}$. 
Generally, we will also now write the judgment $\type{A}$ as $A:\universei{0}$.

\begin{remark}\label[remark]{rmk:meaningless-judgments}
  Universes blur (well, destroy) the distinction between what goes
  on the left- and right-hand side of the typing judgment (``$:$'').
  But then how can we tell which terms correspond to \textit{meaningful}
  propositions?

  If there is a complete and unobjectionable answer to this question,
  it isn't known to classical mathematicians or logicians either. Certain
  well-formed sentences in any formal system might not be particularly
  meaningful. Consider: what is the content of ``$\emptyset∈\pi$'' (where $π∈\R$
  is the usual real number)? For logicians, what is the content of
  $\Diamond\Diamond\Diamond\Diamond\Diamond\Diamond\Diamond P$, in plain
  English? This is a deep and important issue, but decidedly one for
  philosophers, rather than mathematicians and computer scientists.
\end{remark}

\subsection{Predicativity and the universe hierarchy}
\label{subsec:predicativity}

A skeptical reader might point out a possible mistake. If Π-types correspond
to universal quantification and they can quantify over $\universei{0}$, but they
also \textit{are} types, how can we prevent circular (\textit{impredicative})
definitions?\footnote{Indeed, this was Russell's motivation for introducing type
theory in the first place! Note that we can't form the Russellian type of all
types not containing themselves (which would look like
$\∏{A:\universei{0}}\lnot (A:A)$) since the typing judgment ``:'' isn't part of
the language of type theory.}

Of course, sometimes one \textit{does} want to quantify over the whole
universe. When $A\defeq\universei{0}$, then dependent function types 
subsume Haskell- and ML-style parametric polymorphism.\footnote{Those familiar
  with theories such as System F will recognize the next definition, although we
  write lowercase λ for type inputs as well as term inputs. Why? We couldn't do
  otherwise: there is no syntactic distinction.} Accordingly, we now have the
power to write an \textit{single} identity function that works for
\textit{all} types.

\begin{definition}\label[definition]{def:id-polymorphic}
  The identity function is
	\begin{align*}
    \id :\∏{A:\universei{0}}{A\to A} &&
    \id \defeq \λ{A}{\λ{a}{a}}.
  \end{align*}
\end{definition}

If the type $\∏{A:\universei{0}}{A\to A}$ were a member of $\universei{0}$, it
would be self-referential. To resolve this difficulty,
\UTT{} uses a \define{hierarchy of universes} $\universei{0},
\universei{1},\ldots$. In this refined system, one judges
$\universei{i}:\universei{\apply{\suc}{i}}$, and similarly for terms that
quantify over a given universe. For instance, the modified formation rule
for Π looks like the following \cite{cpdt}:
\begin{equation*}
  \prftree[r]{}
    {Γ ⊢ A:\universei{i}}
    {Γ ⊢ B:A→\universei{j}}
    {Γ ⊢ \pitt{a:A}{\apply{B}{a}}:\universei{\appply{\max}{i}{j}}}.
\end{equation*}

\begin{remark}\label[remark]{rmk:universe-polymorphism}
  Are \define{universe indices} part of the object language (\UTT{}) or the
  meta-language? Different type theories make different choices on this matter.
  The proof assistant \Agda{} introduces a type $\ttfun{Level}$ with
  introduction rules
  \begin{align*}
    \prftree[r]{}
      {}
      {Γ ⊢ \ttfun{lzero}:\ttfun{Level}}
    &&
    \prftree[r]{}
      {Γ ⊢ l:\ttfun{Level}}
      {Γ ⊢ \apply{\ttfun{lsucc}}{l}:\ttfun{Level}}
    &&
    \prftree[r]{}
      {\prftree[r, noline]{}
        {Γ ⊢ l_1:\ttfun{Level}}
        {Γ ⊢ l_2:\ttfun{Level}}}
      {Γ ⊢ \appply{\ttfun{lmax}}{l_1}{l_2}:\ttfun{Level}}.
  \end{align*}
  One could now write a \define{universe polymorphic} identity function
	\begin{align*}
    \ttfun{idpoly} :\∏{l:\ttfun{Level}}{\∏{A:\universei{l}}{A\to A}} &&
    \ttfun{idpoly} \defeq \λ{l}{\λ{A}{\λ{a}{a}}}.
  \end{align*}
  This additional power introduces further problems: what is the type the type of
  $\ttfun{idpoly}$ itself? It doesn't actually have one.

  In \UTT{} as in \Coq{}, no quantification over levels is necessary, we treat
  them as symbols in the metalanguage. However, definitions like $\id$ will be
  implicitly treated as defined at all universes.
\end{remark}

\begin{notation}
  Naturally, it gets a bit tedious to manually keep track of all the indices, so
  we follow the standard practice of \define{typical ambiguity}, that is,
  leaving off the universe levels and just writing $\universe$ when no confusion
  may arise.
\end{notation}

\begin{remark}\label[remark]{rmk:cumulativity}
	Typical ambiguity allows for implicit universe polymorphism, as well as
  \define{cumulativity}: we may want to allow for $\universei{i}:\universei{j}$
  for \textit{any} $i<j$, not just $j\defeq \apply{\suc}{i}$ (and similarly for
  Π-types).
\end{remark}

\begin{notation}\label[notation]{implicit-args}
  Often in type theory, functions have ``extraneous'' arguments,
  meaning their values can be deduced from context. For instance, 
  in the (not wellformed) expression $\appply{\id}{\_}{a}$ for $a:A$, the only
  value that can go in the blank is (something judgmentally equal to)
  $A$.\footnote{In \Coq{}, one may actually write $\_$ in place of an
  argument and it will be filled in by a component called the \textit{unifier},
  or declare once and for all that such an argument never needs to be filled in
  when calling the function (such arguments are called \textit{implicit}).}

  As another example, an inhabitant of the following type witnesses the
  associativity of function composition:
  \begin{equation*}
    \∏{A,B,C,D:\universe}{
      \∏{f:A→B}{
        \∏{g:B→C}{
          \∏{h:C→D}{
            \propeq{}{(h∘g)∘f}{h∘(g∘f)}
    }}}}.
  \end{equation*}
  However, the arguments $A$, $B$, $C$, and $D$ can be inferred from the types
  of $f$, $g$, and $h$. In the remainder of this thesis, such arguments may be
  written as subscripts or left out entirely.
\end{notation}

\subsubsection{On the law of the excluded middle}
\label{subsec:on-lem}

Consider functions with the following types:
\begin{itemize}
  \itemsep0em
  \item $\ttfun{dne}:\∏{A:\universe}{((A\to⊥)\to⊥)\to A}$
  \item $\ttfun{lem}:\∏{A:\universe}{A+(A\to⊥)}$
\end{itemize}
What can we tell about these functions from their type signatures?
The term $\ttfun{dne}$ takes as argument a term $x:(A\to⊥)\to⊥$,
that is, a term showing that $A$ is not the empty type\footnote{More precisely,
  $x$ demonstrates that $A$ is not \textit{isomorphic} or \textit{equivalent} to
  $⊥$, in the sense of \cref{subsec:weak-equivalences}. If $A$ were isomorphic
  to $⊥$, then that isomorphism would be an inhabitant of $A\to⊥$.}, and
produces some element of $A$. This seems like a very tricky function to write:
how can we give a term of type $A$ just by knowing $A$ has terms? We don't
know what form data of type $A$ have! The function $\ttfun{lem}$ seems
similarly quagmired. Given a type $A$, this function either has to produce an
element of it, or demonstrate that it is uninhabited.

As you may have already guessed, under the propositions/types correspondence,
these functions correspond to the rule of double negation elimination
($\ttfun{dne}$)\index{Double negation elimination}
and the law of excluded middle ($\ttfun{lem}$)\index{Law of excluded middle}
\cref{def:lem-dne}.

To demonstrate with finality that these are not definable terms in any
consistent type theory,\footnote{They may, however, be taken as axioms. However,
  this naïve version (called LEM\textsubscript{$∞$} in \cite{book}) is
  inconsistent with the univalence axiom. The restriction to \textit{propositions}
  \cref{def:mere-proposition} is consistent with univalence.} consider the
application of $\ttfun{lem}$ to a type $\ttfun{pnp}$ that corresponds to the
$\textsc{P}\neq\textsc{NP}$ conjecture under the types-as-propositions
interpretation. If $\ttfun{lem}$ existed, we could trivially solve this problem
and make a million dollars! The constructive/intuitionistic logic of proof
assistants requires no recourse to philosophy: nothing else computes.

\subsection{Σ-types}
\label{subsec:sigma-types}

The \define{dependent pair type}, or Σ-type, generalizes direct products so that
the type of the second projection might depend on the value of the first.
The rules for Σ-types generalize those for direct products in much the same way
Π-types do for function types:
\begin{gatherjot}
  \prftree[r]{}
    {Γ ⊢ A : \universe}
    {Γ,a:A ⊢ B : \universe}
    {Γ ⊢ \sigmatt{a:A}{\apply{B}{a}} : \universe}
  \qquad
  \prftree[r]{}
    {Γ ⊢ a:A}
    {Γ ⊢ b:\apply{B}{a}}
    {Γ ⊢ \dpair{a}{b}:\sigmatt{a:A}{\apply{B}{a}}} \\
  \prftree[r]{}
    {Γ ⊢ {x}:\sigmatt{a:A}{\apply{B}{a}}}
    {Γ ⊢ \appr{1}{x}:A}
  \qquad
  \prftree[r]{}
    {Γ ⊢ {x}:\sigmatt{a:A}{\apply{B}{a}}}
    {Γ ⊢ \appr{2}{x}:A} \\
  \prftree[r]{βΣ\textsubscript{l}}
    {Γ ⊢ b:\apply{B}{a}}
    {Γ ⊢ a:A}
    {Γ ⊢ \appr{1}{\dpair{a}{b}}\jdeq a:A} 
  \qquad
  \prftree[r]{βΣ\textsubscript{r}}
    {Γ ⊢ b:\apply{B}{a}}
    {Γ ⊢ a:A}
    {Γ ⊢ \appr{2}{\dpair{a}{b}}\jdeq b:A}  \\
  \prftree[r]{η}
    {Γ ⊢ f : \pitt{a:A}{\apply{B}{a}}}
    {Γ ⊢ \λ{x}{\apply{f}{x}}\jdeq f:\pitt{a:A}{\apply{B}{a}}}
\end{gatherjot}

Under the types-as-propositions interpretations, Σ-types correspond to
existential quantification: a pair $\dpair{a}{b}:\∑{a:A}{\apply{B}{a}}$
is an element $a:A$ together with a witness or proof term $b$ which demonstrates
that $a$ has the property $B$. 

\begin{example}\label[example]{ex:ptd}
	The (universe-polymorphic!) type
  \begin{align*}
    \ttfun{Ptd} : \universe && \ttfun{Ptd}\defeq\∑{A:\universe}{A}
  \end{align*}
  consists of pairs $\dpair{A}{a}$ where $a:A$. We might call this the type of 
  \define{pointed} types.
\end{example}

\subsection{The identity type}
\label{subsec:the-identity-type}

\begin{tt-rule}\label[rule]{rule:id-elim}
  The rule of \define{identity elimination} (in the \HoTT{}
  community, known as \define{path induction}) is as follows:\TODO{define id-elim}
\end{tt-rule}

\begin{lemma}[$\ttfun{ap}$]\label[lemma]{lemma:ap}
	\TODO{define ap}
\end{lemma}

\begin{lemma}[Transport]\label[lemma]{lemma:transport}
	\TODO{define transport}
\end{lemma}

\begin{notation}\label[notation]{notation:transport}
  We will often curry\index{Curry} \transportname. If we have a family
  $P:A\to\universe$ and a path $p:\propeq{A}{x}{y}$, we write $\transpor{P}{p}$
  for $\λ{x}\transport{P}{p}{x}$.
\end{notation}

\begin{lemma}\label[lemma]{lemma:transport-compose}
	For $f:A\to B$, $P:B\to\universe$, and $p:\propeq{A}{x}{y}$,
  \begin{equation*}
    \propeq{}{
      \transpor{P∘ f}{p}
    }{
      \transpor{P}{\ap{f}{p}}
    }
  \end{equation*}
\end{lemma}

\subsection{Natural numbers and lists}
\label{subsec:natural-numbers-and-lists}


\section{h-levels and truncation}
\label{sec:h-levels and truncation}

\begin{definition}\label[definition]{def:mere-proposition}
  A type $X:\universe$ is a \define{mere proposition}, a \define{proposition},
  or an \define{hprop} if all of its elements are propositionally equal,
  \begin{equation*}
    \apply{\isProp}{X} \defeq \pit{x,y:X}x=y
  \end{equation*}
\end{definition}

\begin{definition}\label[definition]{def:contr}
  A type $X:\universe$ is \define{contractible} if it is a mere proposition and
  is inhabited, that is
  \begin{equation*}
    \apply{\isContr}{X} \defeq \sigmat{x:X}{\pit{y:X}x=y}
  \end{equation*}
  The first projection is the \define{center} of $X$.
\end{definition}

\begin{definition}\label[definition]{def:sets}

\end{definition}

\begin{figure}[ht]
  \centering
  \caption{\label{fig:awodey} Awodey's two axes: size (universe level)
    and complexity (h-level).}
\end{figure}

\begin{lemma}\label[lemma]{lemma:impred}
  If $X:\universe$, $Y:X→\universe$, and each $\apply{Y}{x}$ is of h-level $n$,
  then $\∏{x:X}{\apply{Y}{x}}$ is of h-level $n$.
\end{lemma}

\section{Univalence}
\label{sec:univalence}

\subsection{Weak equivalences}
\label{subsec:weak-equivalences}

\begin{definition}\label[definition]{def:fiber}
	Given a function $f:A→B$ and point $b:B$, the \define{fiber of $f$ above $b$}
  is the type
  \begin{equation*}
    \∑{a:A}{\propeq{}{\apply{f}{a}}{b}}
  \end{equation*}
\end{definition}

\begin{definition}\label[definition]{def:weq}
  A function $f:A→B$ is a weak equivalence if any of the following
  equivalent\footnote{For proofs that these characterizations are mutually
    equivalent, see \cite{book}.}
  conditions hold:
  \begin{itemize}
    \itemsep0em
    \item the fibers of $f$ are contractible,
      $\∏{b:B}{\apply{\isContr}{\apply{\ttfun{fiber}_f}{b}}}$
    \item TODO
  \end{itemize}
  We abusively denote the type of any of these conditions by
  $\apply{\isEquiv}{f}$.
\end{definition}

\begin{notation}\label[notation]{notation:weq-coerce}
  We may treat a weak equivalence as if it were a function and apply it to an
  argument. This amounts to implicitly applying $\pr{1}$.
\end{notation}

\begin{lemma}\label[lemma]{lemma:isequiv-prop}
	The property of being an equivalence is a proposition.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:contr-weq-unit}
	Any contractible type is weakly equivalent to $\unittype$.
\end{lemma}
\begin{proof}
	Suppose $X:\universe$ is contractible with center $x$. Define $f:X→\unittype$
  as $\λ{x}{\unitelem}$ and $g:\unittype→X$ as $\λ{u}{x}$. Then by hypothesis on
  $X$, the induction principle for $\unittype$\TODO{reference}, and function
  extensionality (\cref{thm:funext}), the composites are the appropriate
  identities.
\end{proof}

\begin{lemma}\label[lemma]{lemma:weq-eq}
  If $A,B:\universe$, $w:\weq{A}{B}$, and $x,y:A$ then
  \begin{equation*}
    \weq{(\propeq{B}{\apply{w}{x}}{\apply{w}{y}})}{(\propeq{A}{x}{y})}
  \end{equation*}
\end{lemma}
\begin{proof}[Proof sketch]
  If $p:\propeq{A}{x}{y}$, then
  $\ap{w}{p}:\propeq{B}{\apply{w}{x}}{\apply{w}{y}}$. Conversely,
  suppose $\propeq{B}{\apply{w}{x}}{\apply{w}{y}}$.
  Then $x$ and $y$ are both in the fiber above $\apply{w}{x}$,
  and since the fibers of a weak equivalence are contractible, $x=y$.
\end{proof}

\begin{corollary}\label[corollary]{cor:weq-contr}
	If $w:\weq{A}{B}$ and $B$ is contractible, so is $A$.
\end{corollary}
\begin{proof}
  By contractibility of $B$, 
  $\propeq{B}{\apply{w}{x}}{\apply{w}{y}}$ for any $a,a':A$, so $A$
  is a mere proposition. Additionally, $w$ has an inverse which sends the center
  $b$ of $B$ to some point $\apply{w^{-1}}{b}$, so $A$ is inhabited.
  Thus, $A$ is contractible.\TODO{reference}
\end{proof}

\begin{lemma}\label[lemma]{lemma:weqfibtototal}
  For any $A:\universe$ and $P,Q:A→\universe$,
  if $\weq{\apply{P}{a}}{\apply{Q}{a}}$ for every $a:A$, then
  \begin{align*}
    \weq{\∏{a:A}{\apply{P}{a}}}{\∏{a:A}{\apply{Q}{a}}}
    &&\text{and}&&
    \weq{\∑{a:A}{\apply{P}{a}}}{\∑{a:A}{\apply{Q}{a}}}
  \end{align*}
\end{lemma}

\subsection{Characterization of paths}
\label{subsec:characterization-of-paths}

A rich family of applications for weak equivalences comes from characterizing
path spaces, that is, saying what counts as an equality between the elements of
a type. For instance, the following restates the η-rule for the product type as
a weak equivalence:

\begin{lemma}\label[lemma]{lemma:paths-dirprod-weq}
  For any $A,B:\universe$, $a:A$, $b:B$, and $x:A×B$,
  \begin{equation*}
    \weq{\big((\propeq{A}{\appr1{x}}{a})×(\propeq{B}{\appr1{x}}{b})\big)}
        {\big(\propeq{}{x}{(a,b)}\big)}
  \end{equation*}
\end{lemma}

\begin{lemma}[Paths in Σ-types]\label[lemma]{lemma:path-sigma}
	If $x,y:\∑{a:A}{B(a)}$, then
  \begin{equation*}
    \weq{
      (\propeq{}{x}{y})
    }{
      \∑{
        p:\propeq{}{\appr{1}{x}}{\appr{1}{y}}
      }{
        \propeq{}{
          \transport{}{p}{\appr{2}{x}}
        }{
          \appr{2}{y}
        }
      }
    }.
  \end{equation*}
  \TODO{cite with page number}
\end{lemma}


\subsection{The univalence axiom}
\label{subsec:the-univalence-axiom}

\begin{definition}\label[definition]{def:ua}
  \TODO{definintion}
  It has the following computation rule:

  Note that this rule holds up to \textit{propositional equality}. This is
  because in \UTT{}, univalence is indeed an \textit{axiom}. It has
  no computational meaning. \TODO{mention CTT}
\end{definition}

\begin{theorem}[Function extensionality]\label[theorem]{thm:funext}
	Under the hypothesis of the univalence axiom, function extensionality holds,
  i.e.\ there is a term
  \begin{equation*}\label{eq:funext}
    \funext:\∏{A,B\:\universe}{(\homot{f}{g})\to \propeq{}{f}{g}}
  \end{equation*}
\end{theorem}

As a simple example of the use of univalence, we can vastly generaize
\cref{lemma:contr-weq}.

\begin{theorem}
	Weak equivalences preserve hlevels.
\end{theorem}
\begin{proof}
  Let $A,B:\universe$, $w:\weq{A}{B}$, and $i:\appply{\hlevel}{n}{A}$.
	Univalence provides an equality $\apply{\ua}{w}:\propeq{\universe}{A}{B}$. 
  Then
  \begin{equation*}
    \transport{\λ{X}{\apply{\isContr}{X}}}{\apply{\ua}{w}}{i} : \appply{\hlevel}{n}{A}
  \end{equation*}
\end{proof}

This argument isn't actually specific to contractibility; using univalence any
proposition of the form ``If $\weq{A}{B}$ and $\apply{P}{A}$, then $\apply{P}{B}$''
trivially true.

\end{document}
